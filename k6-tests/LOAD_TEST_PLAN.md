# E-Commerce 부하 테스트 계획서

## 1. 개요

### 1.1 목적
본 부하 테스트는 이커머스 애플리케이션의 핵심 기능에 대한 성능 검증 및 병목 지점 파악을 목적으로 합니다.

### 1.2 테스트 범위
- 선착순 쿠폰 발급 (동시성 제어 검증)
- 주문 생성 및 결제 프로세스
- 상품 조회 (목록/상세)
- 인기 상품 조회 (Redis 캐시 vs DB)

### 1.3 테스트 도구
- **k6**: Grafana Labs의 오픈소스 부하 테스트 도구
- **버전**: v0.40.0 이상 권장

---

## 2. 테스트 환경

### 2.1 시스템 요구사항

**애플리케이션 서버**
- Spring Boot 3.x
- Java 17+
- 포트: 8080

**데이터베이스**
- MySQL 8.0
- 포트: 3306

**캐시**
- Redis 7.0+
- 포트: 6379

**메시지 큐**
- Kafka 3.x
- 포트: 9092

### 2.2 테스트 데이터 준비

**필수 데이터**
```sql
-- 사용자: 1~1000번 ID
-- 상품: 1~100번 ID, 충분한 재고 (각 1000개 이상)
-- 카테고리: 1~5번 ID
-- 쿠폰: ID 1번 (수량: 100개, 선착순)
```

**데이터 초기화 스크립트**
```bash
# 테스트 전 Redis 초기화
redis-cli FLUSHALL

# 쿠폰 발급 수량 리셋
# (데이터베이스에서 user_coupon 테이블 정리)
```

---

## 3. 테스트 시나리오

### 3.1 선착순 쿠폰 발급 테스트

**테스트 ID**: `LOAD-001`
**파일**: `scenarios/coupon-issue.js`

#### 목적
- Redis Lua Script 기반 동시성 제어 검증
- 정확한 수량 제한 확인 (Race Condition 방지)
- 중복 발급 방지 확인

#### 시나리오
```
- VUs (Virtual Users): 1000명
- Iterations: 1000회
- Duration: 최대 30초
- 쿠폰 수량: 100개 (한정)
```

#### 사용자 행동
1. 1000명의 사용자가 동시에 쿠폰 발급 요청
2. 각 사용자는 고유한 userId 사용 (1~1000)
3. 쿠폰 ID 1번에 대해 발급 시도

#### 예상 결과
```
✅ 성공 발급: 정확히 100개
⚠️  중복 요청: 0개 (동일 사용자 재요청 없음)
🚫 쿠폰 소진: 900개 (410 Gone 응답)
```

#### 성공 기준
- [ ] 발급된 쿠폰 수가 정확히 100개
- [ ] 중복 발급 0건
- [ ] HTTP 요청 실패율 < 1%
- [ ] 응답 시간 P95 < 1초

#### 검증 항목
```
1. 동시성 제어
   - Redis SETNX + Lua Script 원자성 보장
   - 100개 초과 발급 방지

2. 중복 발급 방지
   - 동일 사용자 중복 발급 차단 (409 Conflict)

3. 적절한 에러 응답
   - 쿠폰 소진 시 410 Gone
   - 잘못된 요청 시 400 Bad Request
```

---

### 3.2 주문 생성 부하 테스트

**테스트 ID**: `LOAD-002`
**파일**: `scenarios/order-create.js`

#### 목적
- 주문 생성 프로세스의 처리 성능 측정
- 재고 차감, 결제, 쿠폰 적용의 트랜잭션 안정성 검증
- 멱등성 키를 통한 중복 결제 방지 확인

#### 시나리오
```
- Executor: ramping-vus (점진적 증가)
- Stages:
  1. 1분 동안 0 → 50명으로 증가
  2. 3분 동안 50명 유지
  3. 1분 동안 50 → 0명으로 감소
- Total Duration: 5분
```

#### 사용자 행동
1. 랜덤 사용자 ID로 주문 생성 요청
2. 멱등성 키 생성 (timestamp + VU + iteration)
3. 주문 생성 후 주문 상세 조회
4. 2~5초 대기 (다음 주문까지)

#### 예상 결과
```
✅ 성공률: > 95%
⏱️  평균 응답 시간: < 1초
⏱️  P95 응답 시간: < 2초
📊 처리량: > 10 TPS
```

#### 성공 기준
- [ ] 주문 성공률 > 95%
- [ ] 응답 시간 P95 < 2초
- [ ] HTTP 요청 실패율 < 1%
- [ ] 멱등성 키 중복 시 적절한 처리

#### 검증 항목
```
1. 트랜잭션 일관성
   - 재고 차감 정확성
   - 결제 처리 완료
   - 주문 상태 PAID 확인

2. 동시성 제어
   - 재고 부족 시 적절한 에러 처리
   - 잔액 부족 시 주문 실패

3. 멱등성 보장
   - 동일 멱등성 키 중복 요청 방지
```

---

### 3.3 상품 조회 부하 테스트

**테스트 ID**: `LOAD-003`
**파일**: `scenarios/product-list.js`

#### 목적
- 상품 목록/상세 조회 API의 처리량 측정
- 높은 동시 접속 환경에서의 응답 성능 확인
- 페이징 처리 성능 검증

#### 시나리오
```
- Executor: ramping-vus (스트레스 테스트)
- Stages:
  1. 2분 동안 0 → 100명으로 증가
  2. 5분 동안 100명 유지
  3. 2분 동안 100 → 200명으로 증가
  4. 5분 동안 200명 유지
  5. 2분 동안 200 → 0명으로 감소
- Total Duration: 16분
```

#### 사용자 행동
1. 상품 목록 조회 (랜덤 페이지 0~4)
2. 0.5~1초 대기
3. 상품 상세 조회 (목록에서 랜덤 선택)
4. 0.5~1초 대기
5. 카테고리별 상품 조회 (카테고리 1~5)
6. 1~3초 대기 (다음 조회까지)

#### 예상 결과
```
✅ 성공률: > 99%
⏱️  목록 조회 P95: < 500ms
⏱️  상세 조회 P95: < 300ms
📊 처리량: > 100 TPS
```

#### 성공 기준
- [ ] 조회 성공률 > 99%
- [ ] 목록 조회 P95 < 500ms
- [ ] 상세 조회 P95 < 300ms
- [ ] HTTP 요청 실패율 < 0.1%

#### 검증 항목
```
1. 조회 성능
   - 페이징 처리 응답 시간
   - 상세 조회 응답 시간
   - 높은 처리량 유지

2. 데이터 정확성
   - 페이징 정보 일치
   - 상품 ID 일치
   - 상품 정보 완전성
```

---

### 3.4 인기 상품 조회 부하 테스트

**테스트 ID**: `LOAD-004`
**파일**: `scenarios/popular-products.js`

#### 목적
- Redis 캐시 기반 인기 상품 조회 성능 검증
- DB 기반 집계와 Redis 기반 실시간 집계 성능 비교
- 급격한 트래픽 증가 시 안정성 확인 (Spike Test)

#### 시나리오
```
- Executor: ramping-vus (스파이크 테스트)
- Stages:
  1. 10초 동안 0명 유지 (준비)
  2. 10초 만에 0 → 500명으로 급증
  3. 3분 동안 500명 유지
  4. 10초 만에 500 → 0명으로 감소
- Total Duration: 약 4분
```

#### 사용자 행동
1. 실시간 인기 상품 조회 (Redis Sorted Set)
2. 0.3~0.7초 대기
3. 실시간 인기 상품 + 통계 조회
4. 0.3~0.7초 대기
5. DB 기반 인기 상품 조회 (최근 3일 집계)
6. 1~2초 대기 (다음 조회까지)

#### 예상 결과
```
[Redis 실시간]
✅ 성공률: > 99%
⏱️  평균: < 50ms
⏱️  P95: < 100ms

[Redis + 통계]
✅ 성공률: > 99%
⏱️  평균: < 80ms
⏱️  P95: < 150ms

[DB 집계]
✅ 성공률: > 99%
⏱️  평균: < 300ms
⏱️  P95: < 500ms

💡 성능 비교: Redis는 DB보다 5~10배 빠름
```

#### 성공 기준
- [ ] Redis 조회 P95 < 100ms
- [ ] Redis Stats 조회 P95 < 150ms
- [ ] DB 조회 P95 < 500ms
- [ ] HTTP 요청 실패율 < 0.1%

#### 검증 항목
```
1. Redis 캐시 성능
   - Sorted Set ZREVRANGE 연산 속도
   - 높은 동시 접속 시 안정성
   - 급격한 트래픽 증가 대응

2. 성능 비교 분석
   - Redis vs DB 응답 시간 비교
   - 캐시 효과 정량화

3. 데이터 정확성
   - 순위 정확성
   - 판매 수량 일치
```

---

## 4. 성능 목표 및 임계값

### 4.1 전체 성능 목표

| 메트릭 | 목표 | 설명 |
|--------|------|------|
| **가용성** | 99.9% | 전체 시스템 가동률 |
| **응답 시간 (P95)** | < 1초 | 95%의 요청이 1초 이내 응답 |
| **처리량 (TPS)** | > 100 | 초당 100건 이상 처리 |
| **에러율** | < 1% | 전체 요청의 1% 미만 실패 |

### 4.2 API별 성능 임계값

| API | P50 | P95 | P99 | TPS |
|-----|-----|-----|-----|-----|
| **쿠폰 발급** | < 300ms | < 1s | < 2s | 50+ |
| **주문 생성** | < 800ms | < 2s | < 3s | 10+ |
| **상품 목록** | < 200ms | < 500ms | < 1s | 100+ |
| **상품 상세** | < 100ms | < 300ms | < 500ms | 200+ |
| **인기 상품 (Redis)** | < 50ms | < 100ms | < 200ms | 500+ |
| **인기 상품 (DB)** | < 200ms | < 500ms | < 1s | 100+ |

### 4.3 k6 Thresholds 설정

```javascript
// 공통 임계값 (config.js)
export const THRESHOLDS = {
  // HTTP 요청 실패율 < 1%
  http_req_failed: ['rate<0.01'],

  // 95 백분위수 응답 시간
  http_req_duration: {
    fast: ['p(95)<200'],      // 조회 API
    normal: ['p(95)<500'],    // 일반 API
    slow: ['p(95)<1000'],     // 복잡한 트랜잭션
  },

  // HTTP 요청 성공 응답 체크
  checks: ['rate>0.99'],      // 99% 이상 성공
};
```

---

## 5. 테스트 실행 계획

### 5.1 실행 순서

```bash
# 1단계: Smoke Test (기본 동작 확인)
k6 run --vus 1 --duration 30s scenarios/product-list.js

# 2단계: 개별 테스트 (순차 실행)
k6 run scenarios/coupon-issue.js
k6 run scenarios/order-create.js
k6 run scenarios/product-list.js
k6 run scenarios/popular-products.js

# 3단계: 결과 분석 및 개선
# (성능 개선 후 재테스트)
```

### 5.2 테스트 전 체크리스트

- [ ] Spring Boot 애플리케이션 실행 중 (`./gradlew bootRun`)
- [ ] MySQL 실행 중 및 연결 확인
- [ ] Redis 실행 중 및 연결 확인
- [ ] Kafka 실행 중 및 연결 확인
- [ ] 테스트 데이터 준비 완료 (사용자, 상품, 쿠폰)
- [ ] k6 설치 완료 (`k6 version`)
- [ ] 로그 모니터링 준비 (애플리케이션 로그, DB 슬로우 쿼리)

### 5.3 테스트 중 모니터링

**애플리케이션 모니터링**
- CPU 사용률
- 메모리 사용률
- 스레드 풀 상태
- GC 빈도 및 시간

**데이터베이스 모니터링**
- 연결 수
- 슬로우 쿼리
- Lock 대기 시간
- 인덱스 사용률

**Redis 모니터링**
- 명령어 처리 속도
- 메모리 사용률
- 초당 연산 수 (OPS)

**Kafka 모니터링**
- 메시지 지연 시간
- 컨슈머 랙 (Lag)
- 파티션 처리량

---

## 6. 결과 분석 및 개선

### 6.1 분석 항목

1. **성능 메트릭**
   - 응답 시간 분포 (P50, P95, P99)
   - 처리량 (TPS, RPS)
   - 에러율 및 에러 유형

2. **병목 지점 식별**
   - 응답 시간이 긴 API
   - 에러율이 높은 구간
   - 리소스 사용률이 높은 시점

3. **동시성 제어 검증**
   - 쿠폰 발급 수량 정확성
   - 재고 차감 정확성
   - Race Condition 발생 여부

### 6.2 개선 방안

**성능 개선**
- [ ] DB 쿼리 최적화 (인덱스 추가, N+1 해결)
- [ ] Redis 캐시 적용 확대
- [ ] 커넥션 풀 크기 조정
- [ ] 비동기 처리 도입 (Kafka, Spring Events)

**안정성 개선**
- [ ] Circuit Breaker 패턴 적용
- [ ] Retry 정책 수립
- [ ] Rate Limiting 적용
- [ ] 에러 처리 개선

**확장성 개선**
- [ ] 수평 확장 (Scale-out) 검증
- [ ] 로드 밸런싱 적용
- [ ] 데이터베이스 샤딩 검토

---

## 7. 리스크 및 제약사항

### 7.1 리스크

| 리스크 | 영향도 | 대응 방안 |
|--------|--------|-----------|
| 테스트 데이터 부족 | 높음 | 데이터 생성 스크립트 사전 실행 |
| 인프라 리소스 부족 | 중간 | 클라우드 환경에서 테스트 또는 리소스 증설 |
| 운영 DB 영향 | 높음 | 별도 테스트 환경 구축 필수 |
| 테스트 중 장애 | 중간 | 모니터링 강화 및 롤백 계획 수립 |

### 7.2 제약사항

- 로컬 환경에서 테스트 시 성능 제한
- 네트워크 대역폭 제약
- 단일 서버 구성으로 인한 확장성 제한

---

## 8. 참고 자료

- [k6 공식 문서](https://k6.io/docs/)
- [k6 부하 테스트 모범 사례](https://k6.io/docs/testing-guides/test-types/)
- [Redis Lua Script 성능 최적화](https://redis.io/docs/manual/programmability/eval-intro/)
- [Spring Boot 성능 튜닝 가이드](https://spring.io/guides/gs/performance/)

---

## 9. 변경 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|-----------|
| 1.0 | 2025-12-25 | k6 Team | 초기 작성 |

